package app

import (
	"bytes"
	"fmt"
	"github.com/greenstatic/kga/pkg/files"
	"github.com/greenstatic/kga/pkg/log"
	"github.com/greenstatic/kga/pkg/yamlmanipulation"
	"github.com/pkg/errors"
	"gopkg.in/yaml.v2"
	"io/ioutil"
	"os"
	"path/filepath"
	"reflect"
	"text/template"
)

type PathIsNotKgaAppError string
func (p PathIsNotKgaAppError) Error() string {
	return fmt.Sprintf("App path: %s is not a kga app", string(p))
}

func Generate(path string) error {
	isKgaApp, err := PathIsKgaApp(path)
	if err != nil {
		return err
	}
	if !isKgaApp {
		return PathIsNotKgaAppError(path)
	}

	config, err := ParseFromFileConfig(filepath.Join(path, "kga.yaml"))
	if err != nil {
		return errors.Wrap(err, "failed to parse kga.yaml file")
	}

	if err := config.Verify(); err != nil {
		return err
	}

	// App type specific generate
	appType := CreateType(config.Spec.Type)
	if err := appType.generate(config, path); err != nil {
		return err
	}

	return nil
}

// Writes to the <basePath>/kustomization.yaml file all the resources in
// <basePath>/manifests and places
func generateBase(basePath string) error {
	manifestResources, err := files.EnumerateAllFiles(filepath.Join(basePath, "manifests"))
	if err != nil {
		return err
	}

	kData, err := baseKustomization(manifestResources)
	if err != nil {
		return err
	}

	return ioutil.WriteFile(filepath.Join(basePath, "kustomization.yaml"), kData, os.FileMode(0640))
}


func baseKustomization(manifestResources []string) ([]byte, error) {
	templateStr := `# This file has been generated by kga
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
{{ range $val := . }}- manifests/{{ $val }}
{{ end }}`

	tmpl := template.Must(template.New("kustomization").Parse(templateStr))

	buf := new(bytes.Buffer)
	if err := tmpl.Execute(buf, manifestResources); err != nil {
		return []byte{}, err
	}

	return buf.Bytes(), nil
}


func removeExcludedResources(manifestsPath, excludedManifestsPath string, excludedManifests *[]ExcludeItemSpec) error {
	files_, err := ioutil.ReadDir(manifestsPath)
	if err != nil {
		return err
	}

	keptResourcesCount := 0
	excludedResourcesCount := 0

	for _, f := range files_ {
		if f.IsDir() {
			continue
		}
		content, err := ioutil.ReadFile(filepath.Join(manifestsPath, f.Name()))
		if err != nil {
			return err
		}

		contentStr := string(content)
		yamls := yamlmanipulation.DocumentsSeperate(contentStr)

		fileManifestDocuments := make([]yamlmanipulation.Document, 0)
		excludedDocuments := make([]yamlmanipulation.Document, 0)

		for _, exclude := range *excludedManifests {
			for _, yamlDoc := range yamls {
				ymlDoc := new(interface{})
				if err := yaml.Unmarshal([]byte(string(yamlDoc)), ymlDoc); err != nil {
					return err
				}

				excludeDoc := reflect.ValueOf(exclude).Interface()
				match, err := yamlmanipulation.ExcludeItemMatchesResource(&excludeDoc, ymlDoc)
				if err != nil {
					return err
				}

				if match {
					//excludedDocuments, _ := excludedDocuments[f.Name()]
					excludedDocuments = append(excludedDocuments, yamlDoc)

				} else {
					fileManifestDocuments = append(fileManifestDocuments, yamlDoc)
				}
			}
		}

		// Override the manifest file with the non excluded YAML documents
		manifestContent := yamlmanipulation.DocumentsJoin(fileManifestDocuments)
		if err := ioutil.WriteFile(filepath.Join(manifestsPath, f.Name()), []byte(manifestContent), os.FileMode(0640)); err != nil {
			return err
		}
		keptResourcesCount += len(fileManifestDocuments)

		// Add excluded documents to <app>/base/excluded/
		if len(excludedDocuments) > 0 {
			exists, err := files.FileOrDirExists(excludedManifestsPath)
			if err != nil {
				return err
			}

			if !exists {
				// Create excluded dir
				if err := os.Mkdir(excludedManifestsPath, os.FileMode(0755)); err != nil {
					return err
				}
			}

			// Add file with excluded content
			excludedContent := yamlmanipulation.DocumentsJoin(excludedDocuments)
			if err := ioutil.WriteFile(filepath.Join(excludedManifestsPath, f.Name()), []byte(excludedContent), os.FileMode(0640)); err != nil {
				return err
			}
		}
		excludedResourcesCount += len(excludedDocuments)
	}

	log.Infof("Kept: %d resources, excluded: %d resources", keptResourcesCount, excludedResourcesCount)

	return nil
}
